**1. Вопросы**

Надо ответить, как работают и взаимодействуют:

✅ Handlers (контроллеры) – принимают запросы и вызывают сервисы.
✅ Services (бизнес-логика) – выполняют операции над данными.
✅ Repositories (работа с БД) – обращаются к PostgreSQL

**2. Ответ**

В main.go мы создаем репозиторий, сервис с бизнес логикой и инициализируем API.

Как это всё работает:
- Мы инициализируем репозиторий, во время создания наш новый репозиторий подключается к БД, используя данные о самой базе, указанные в .env файле.
- После мы создаем объект сервиса, при создании передаем туда объект репозитория, к которому сервис будет обращаться.
- Затем создаем наш API, куда передаем наш сервис, что роутер знал, чьи методы мы запускаем.

Вот наш проект создал все нужные объекты, готовые к работе, и прилетает запрос. Каждый хэндлер слушает определённый URL и вызывает соответствующий метод.

(
    
    У нас есть 2 пути:

        apiGroup.Post("/create_task", r.Service.CreateTask)
        apiGroup.Get("/task/:id", r.Service.GetTaskById)

    При обращении к "/task/:id" контроллер вызовет метод GetTaskById у сервиса, который мы указывали при создании API. Никаким образом по этому адресу мы не попадем в CreateTask.

)

После чего мы попадаем на слой Services - происходит какая-то бизнес-логика нашего приложения (в нашем случае мы просто создаем задачи или получаем задачи по ID, но на этом слое могут происходить куда более сложные и комплексные операции с данными). По ходу своей работы мы можем обращаться к уровню Repositories , чтобы тот выполнил для нас какую-то операцию с БД. 

Уровень Repositories нужен для того, чтобы наш код мог взаимодействовать с БД. Все операции добавления, удаления или редактирования данных в базе определяются и исполняются на этом уровне. Это сделано для того, чтобы все другие слои знали методы нашего репозитория и никак не зависили от самой БД - если в какой-то момент нам придется перейти с PostgreSQL на MySQL, или вообще на какой нибудь Redis (пример из головы, высосаный из пальца) - нам придется менять только слой Repositories, не затрагивая никаким образом остальные слои - пока методы репозитория принимают в качестве аргументов то же, что и до изменения, и возвращают те же данные, что и до изменения, остальным слоям плевать на то, как работает слой репозитория. 